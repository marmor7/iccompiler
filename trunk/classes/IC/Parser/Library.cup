package IC.LibraryParser;

import IC.AST.*;
import IC.Parser.*;
import IC.Parser.sym;
import java.util.*;
import IC.DataTypes;
import java_cup.runtime.Symbol;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public boolean printTokens = false;
	
	private Lexer lexer;

	public LibraryParser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	public void syntax_error(Symbol s) throws SyntaxError{
        Token tok = (Token) s;
        throw new SyntaxError(tok);
    }
	
:}
// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		t.printToken();
	return t; 
:};

action code {:

	int classLine = 0;

:}

terminal LENGTH;
terminal NEW;
terminal MOD;
terminal NULL;
terminal RETURN;
terminal SEMI;
terminal STATIC;
terminal STRING;
terminal QUOTE;
terminal THIS;
terminal VOID;

terminal EQUAL; 
terminal NEQUAL;
terminal LOR;
terminal LAND;
terminal LNEG;
terminal WHILE;

terminal CONTINUE;
terminal DOT;
terminal EXTENDS;
terminal IF;
terminal ELSE;
terminal String ID;

terminal LP;
terminal RP;
terminal LCBR;
terminal RCBR;
terminal COMMA;
terminal LB;
terminal RB;
terminal GT;
terminal LT;
terminal LTE;
terminal GTE;
terminal FALSE;
terminal TRUE;
terminal INT;
terminal INTEGER;
terminal MINUS;
terminal MULTIPLY;
terminal PLUS;
terminal DIVIDE;
terminal CLASS;
terminal String CLASS_ID;
terminal ASSIGN;
terminal BOOLEAN;
terminal BREAK;	

non terminal ICClass				libic;
non terminal LinkedList<Method>		methodwrapper;
non terminal LinkedList<Method>		libmethod;
non terminal PrimitiveType			typeorvoid;
non terminal PrimitiveType			type;
non terminal 						bracket;
non terminal LinkedList<Formal>		paren;
non terminal LinkedList<Formal>		param;
non terminal LinkedList<Formal>		paramfactory;


libic ::=
		{:
			RESULT = new ICClass(0, "", new LinkedList<Field>(), new LinkedList<Method>()); 
		:}  
		|
		CLASS CLASS_ID:c 
		{: 
			classLine = this.parser.getLine();
		:} 
		methodwrapper:mlist
		{: 
			RESULT = new ICClass(classLine, c, new LinkedList<Field>(), mlist); 
		:}
		;
methodwrapper ::= LCBR libmethod:mlist RCBR
		{: 
			RESULT = mlist;
		:} 
		| 
		LCBR RCBR
		{: 
			RESULT = new LinkedList<Method>();
		:} 
		;
libmethod ::= libmethod:mlist STATIC typeorvoid:t ID:id paren:plist
		{:
			mlist.add(new LibraryMethod(t, id, plist));
			RESULT = mlist;
		:} 
		|
		STATIC typeorvoid:t ID:id paren:plist
		{: 
			LinkedList<Method> mlist = new LinkedList<Method>();
			mlist.add(new LibraryMethod(t, id, plist));
			RESULT = mlist;
		:} 
		;

typeorvoid ::= type:t 
		{:
			RESULT = t;
		:}
		| 
		VOID
		{: 
			RESULT = new PrimitiveType(this.parser.getLine(), DataTypes.VOID);
		:} 
		;
type ::= INT 
		{: 
			RESULT = new PrimitiveType(this.parser.getLine(), DataTypes.INT);
		:} 
		| 
		STRING 
		{:
			RESULT = new PrimitiveType(this.parser.getLine(), DataTypes.STRING);
		:} 
		| 
		BOOLEAN 
		{:
			RESULT = new PrimitiveType(this.parser.getLine(), DataTypes.BOOLEAN);
		:} 
		| 
		INT bracket 
		{:
			PrimitiveType t = new PrimitiveType(this.parser.getLine(), DataTypes.INT);
			t.incrementDimension();
			RESULT = t;
		:} 
		| 
		STRING bracket 
		{:
			PrimitiveType t = new PrimitiveType(this.parser.getLine(), DataTypes.STRING);
			t.incrementDimension();
			RESULT = t;
		:} 
		| 
		BOOLEAN bracket
		{:
			PrimitiveType t = new PrimitiveType(this.parser.getLine(), DataTypes.BOOLEAN);
			t.incrementDimension();
			RESULT = t;
		:}  
		;
bracket ::= LB RB;
paren ::= LP param:plist RP SEMI 
		{: 
			RESULT = plist;
		:} 
		;
param ::= paramfactory:pf type:t ID:id 
		{:
			
			pf.add(new Formal(t, id));
			RESULT = pf;
		:}
		|
		{: 
			RESULT = new LinkedList<Formal>();
		:}
		;
		
paramfactory ::= paramfactory:pf type:tp ID:id COMMA 
		{:
			pf.add(new Formal(tp,id));
			RESULT = pf;
		:}
		|
		{:
			RESULT = new LinkedList<Formal>();
		:}
		;
