package IC.Parser;

import IC.*;
import IC.AST.*;
import java.util.*;
import IC.DataTypes;
import java_cup.runtime.Symbol;

parser code  {:
	/** Causes the parsr to print every token it reads.
	 * This is useful for debugging.
	 */
	public static boolean printTokens = false;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return lexer.getLineNumber();
	}
	
	public void syntax_error(Symbol s) throws SyntaxError{
        Token tok = (Token) s;
        throw new SyntaxError(tok);
    }
:}

// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		t.printToken();
	return t; 
:};


terminal LENGTH;
terminal NEW;
terminal MOD;
terminal NULL;
terminal RETURN;
terminal SEMI;
terminal STATIC;
terminal STRING;
terminal QUOTE;
terminal THIS;
terminal VOID;

terminal EQUAL; 
terminal NEQUAL;
terminal LOR;
terminal LAND;
terminal LNEG;
terminal WHILE;

terminal CONTINUE;
terminal DOT;
terminal EXTENDS;
terminal IF;
terminal ELSE;
terminal String ID;

terminal LP;
terminal RP;
terminal LCBR;
terminal RCBR;
terminal COMMA;
terminal LB;
terminal RB;
terminal GT;
terminal LT;
terminal LTE;
terminal GTE;
terminal FALSE;
terminal TRUE;
terminal INT;
terminal INTEGER;
terminal MINUS;
terminal MULTIPLY;
terminal PLUS;
terminal DIVIDE;
terminal CLASS;
terminal String CLASS_ID;
terminal ASSIGN;
terminal BOOLEAN;
terminal BREAK;	
terminal UMINUS;

nonterminal Program 			program;
nonterminal LinkedList<ICClass> classDecl;
nonterminal String				extendswrapper;
nonterminal ArrayList<Object>	fieldormethodwrapper;
nonterminal LinkedList<Field>	field;
nonterminal Method 				method;
nonterminal ArrayList<Object>	fieldormethod;
nonterminal Type				type;
nonterminal Type				usertype;
nonterminal ArrayList<String>	idfactory;

nonterminal LinkedList<Formal>		formals;
nonterminal LinkedList<Formal>		formalsfactory;
nonterminal LinkedList<Statement>	stmtwrapper;
nonterminal Statement				stmt;
nonterminal Location				location;
nonterminal Expression				expr;
nonterminal Call					call;
nonterminal VirtualCall				virtualCall;
nonterminal StaticCall				staticCall;
nonterminal LinkedList<Expression>	commaexprorepislon;
nonterminal LinkedList<Expression>	commaexprfactory;
nonterminal BinaryOps				lbinop;
nonterminal UnaryOps				lunop;
nonterminal UnaryOps				munop;
nonterminal Object[2]				literal;
nonterminal 						bracket;
nonterminal Expression 				lpexprrp;

precedence right ELSE;
precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL,NEQUAL;
precedence left GT,LT,GTE,LTE;
precedence left PLUS, MINUS;
precedence left MULTIPLY,DIVIDE, MOD;
precedence right UMINUS,LNEG;
precedence left LP,RP,LB,RB,DOT;



program ::= classDecl:cl
			{:
				RESULT = new Program(cl);
			:}
			;

classDecl::= classDecl:cdl CLASS CLASS_ID:id extendswrapper:ext LCBR fieldormethodwrapper:fmw RCBR
			{:
				if (ext != null)
					cdl.add(new ICClass(idleft,id, ext, (LinkedList<Field>)fmw.get(1), (LinkedList<Method>)fmw.get(0)));
				else
					cdl.add(new ICClass(idleft,id, (LinkedList<Field>)fmw.get(1), (LinkedList<Method>)fmw.get(0)));
				RESULT = cdl;
			:}
			| 
			{:
				RESULT = new LinkedList<ICClass>();
			:}
			;

extendswrapper ::= EXTENDS CLASS_ID:id
			{:
				RESULT = id;
			:}
			|
			{:
				RESULT = null;
			:}
			;

fieldormethodwrapper ::= fieldormethodwrapper:fmw fieldormethod:fm
			{:
				int x = (Integer)fm.get(0);
				if (x ==0){
					((LinkedList<Method>)fmw.get(0)).add((Method)fm.get(1));
				}
				else{
					((LinkedList<Field>)fmw.get(1)).addAll( (LinkedList<Field>)fm.get(1));
				}
				RESULT = fmw;
			:}
			|
			{:
				ArrayList<Object> acc = new ArrayList<Object>();
				acc.add(new LinkedList<Method>());
				acc.add(new LinkedList<Field>());
				RESULT = acc;
			:}
			;

fieldormethod ::= field:fld
			{:
				ArrayList<Object> acc = new ArrayList<Object>();
				Integer x = 1;
				acc.add(x);
				acc.add(fld);
				RESULT = acc;
			:}
			|
			method:mthd
			{:
				ArrayList<Object> acc = new ArrayList<Object>();
				Integer x = 0;
				acc.add(x);
				acc.add(mthd);
				RESULT = acc;
			:}
			;
type ::= BOOLEAN {: RESULT = new PrimitiveType(this.parser.getLine(), DataTypes.BOOLEAN); :}
| INT {: RESULT = new PrimitiveType(this.parser.getLine(), DataTypes.INT); :}
| STRING {: RESULT = new PrimitiveType(this.parser.getLine(), DataTypes.STRING); :}
| CLASS_ID:cid {: RESULT =new UserType(cidleft,cid); :}
| type:t LB RB {: RESULT = t; t.incrementDimension(); :}
;
bracket::= LB RB;

field::= type:tp ID:id idfactory:idf SEMI
		{:
			LinkedList<Field> b = new LinkedList<Field>();
	    	for (int i=0;i<idf.size();i++)
	    		b.add(new Field(tp,idf.get(i)));
	    	b.add(new Field(tp,id));
	    	RESULT = b;
		:}
;

idfactory::=  idfactory:idf COMMA ID:id
			{:
				idf.add(id);
				RESULT = idf;
			:} 
			| 
			{:
				RESULT = new ArrayList<String>();
			:}
			;

method::= STATIC type:tp ID:id LP formals:frml RP LCBR stmtwrapper:stmtwrp RCBR
 			{:
				RESULT = new StaticMethod(tp, id,frml,stmtwrp);
			:} 
			|
			STATIC VOID ID:id LP formals:frml RP LCBR stmtwrapper:stmtwrp RCBR
			{:
				RESULT = new StaticMethod(new PrimitiveType(idleft,DataTypes.VOID), id,frml,stmtwrp);
			 :} 
			|
			type:tp ID:id LP formals:frml RP LCBR stmtwrapper:stmtwrp RCBR 
			{:
				RESULT = new VirtualMethod(tp, id,frml,stmtwrp);
			:}
			|
			VOID ID:id LP formals:frml RP LCBR stmtwrapper:stmtwrp RCBR 
			{:
				RESULT = new VirtualMethod(new PrimitiveType(idleft,DataTypes.VOID), id,frml,stmtwrp);
			:}
			;

formals::= formalsfactory:fctry type:tp ID:id
		   {:
				fctry.add(new Formal(tp,id));
				RESULT = fctry;
		   :} 
			|
			{:
				RESULT = new LinkedList<Formal>();
			:}
			 ;

formalsfactory::= formalsfactory:fctry type:tp ID:id COMMA 
			{:
				fctry.add(new Formal(tp,id));
				RESULT = fctry;
		   :}
			|
			{:
				RESULT = new LinkedList<Formal>();
			:}
			 ;

stmtwrapper::= stmtwrapper:wrap stmt:stm 
			{:
 				wrap.add(stm);
 				RESULT = wrap;
			:}
			|
			{: 
				RESULT = new LinkedList<Statement>();
			:}
			 ;

stmt::= location:loc ASSIGN expr:exp SEMI
			{:
				RESULT = new Assignment(loc,exp);
			:}
			|
			 call:cll SEMI
			 {:
				RESULT = new CallStatement(cll);
			:}
			|
			RETURN:left SEMI
			{:
				RESULT = new Return(leftleft);
			:}
			|
			RETURN expr:exp SEMI
			{:
				RESULT = new Return(expleft,exp);
			:}
			|
			IF lpexprrp:cond stmt:stm
			{:
				RESULT = new If(cond,stm);
			:}
			|
			IF lpexprrp:cond stmt:stm1 ELSE stmt:stm2
			{:
				RESULT = new If(cond,stm1,stm2);
			:}
			|
			WHILE LP expr:cond RP stmt:stm
			{:
				RESULT = new While(cond,stm);
			:}
			|
			BREAK:left SEMI
			{:
				RESULT = new Break(leftleft);
			:}
			|
			CONTINUE:left SEMI
			{:
				RESULT = new Continue(leftleft);
			:}
			|
			LCBR:lcbr stmtwrapper:stmtlist RCBR
			{:
				RESULT = new StatementsBlock(lcbrleft,stmtlist);
			:} 
			|
			 type:tp ID:id SEMI
			{:
				RESULT = new LocalVariable(tp,id);
			:} 
			|
			type:tp ID:id ASSIGN expr:exp SEMI
			{:
				RESULT = new LocalVariable(tp,id,exp);
			:}
			;

lpexprrp::= LP expr:exp RP
			{:
				RESULT = exp;
			:}
			;
			
location::= ID:name
 			{:	
				RESULT = new VariableLocation(nameleft,name);
			:}
			|
			expr:exp DOT ID:name
			{:	
				RESULT = new VariableLocation(nameleft,exp,name);
				
			:} 
			|
			expr:arr LB expr:exp RB
			{:
				RESULT = new ArrayLocation(arr,exp);
			:}
			;

expr::= 	location:loc 
			{:
				RESULT = loc;
			:}
			|			
			NEW type:t LB expr:e RB
			{:
			 	RESULT = new NewArray(t,e);
			:}
			|
			call:cll
			{:
			 	RESULT = cll;
			:}
			|
			THIS:left
			{:
			 	RESULT = new This(leftleft);
			:}
			|
			NEW CLASS_ID:cid LP RP
			{:
			 	RESULT = new NewClass(cidleft, cid);
			:}
			|
			expr:arr DOT LENGTH
			{:
				RESULT = new Length(arr);
			:}
			|
			expr:exp1 lbinop:op expr:exp2
			{:
				RESULT = new LogicalBinaryOp(exp1,op,exp2);
			:}
			|
			expr:exp1 PLUS expr:exp2
			{:
				RESULT = new MathBinaryOp(exp1,BinaryOps.PLUS,exp2);
			:}	
			|
			expr:exp1 MINUS expr:exp2
			{:
				RESULT = new MathBinaryOp(exp1,BinaryOps.MINUS,exp2);
			:}	
			|
			expr:exp1 MULTIPLY expr:exp2
			{:
				RESULT = new MathBinaryOp(exp1,BinaryOps.MULTIPLY,exp2);
			:}	
			|
			expr:exp1 DIVIDE expr:exp2
			{:
				RESULT = new MathBinaryOp(exp1,BinaryOps.DIVIDE,exp2);
			:}	
			|
			expr:exp1 MOD expr:exp2
			{:
				RESULT = new MathBinaryOp(exp1,BinaryOps.MOD,exp2);
			:}
			|
			munop:unp expr:exp
			{:
				RESULT = new MathUnaryOp(unp,exp);
			:}
			|
			lunop:unp expr:exp
			{:
				RESULT = new LogicalUnaryOp(unp,exp);
			:}
			|
			literal:ltrl
			{:
				RESULT = new Literal(ltrlleft,(LiteralTypes)ltrl[0],ltrl[1]);
			:}
			|
			LP expr:exp RP
			{:
				RESULT = new ExpressionBlock(exp);
			:}
			;

call::= staticCall:sc
			{:
				RESULT = sc;
			:}
			|
			virtualCall:vc
			{:
				RESULT = vc;
			:}
			;

staticCall::=CLASS_ID:cid DOT ID:id LP commaexprorepislon:explist RP
			{:
				RESULT = new StaticCall(idleft, cid,id, explist); 
			:}
			;

commaexprorepislon::= commaexprfactory:cef expr:exp
			{:
				cef.add(exp);
				RESULT = cef;
			:}
			| 
			{:
				RESULT = new LinkedList<Expression>();
			:}
			;

commaexprfactory::= commaexprfactory:cef expr:exp COMMA
 			{:
 				cef.add(exp);
 				RESULT = cef;
 			:}
			|
			{:
				RESULT = new LinkedList<Expression>();
			:}
			;

virtualCall::=
			expr:ex DOT ID:met LP commaexprorepislon:plist RP 
			{:
				RESULT = new VirtualCall(exleft, ex, met, plist); 
			:} 
			|
			ID:met LP commaexprorepislon:plist RP
			{:
				RESULT = new VirtualCall(metleft, met, plist); 
			:} 
			;

lbinop::=	LAND:tok
			{:
				RESULT = BinaryOps.LAND; 
			:}
			|
			LOR:tok
			{:
				RESULT = BinaryOps.LOR; 
			:}
			|
			GT:tok
			{:
				RESULT = BinaryOps.GT; 
			:}
			|
			GTE:tok
			{:
				RESULT = BinaryOps.GTE; 
			:}
			|
			LT:tok
			{:
				RESULT = BinaryOps.LT; 
			:}
			|
			LTE:tok
			{:
				RESULT = BinaryOps.LTE; 
			:}
			|
			NEQUAL:tok
			{:
				RESULT = BinaryOps.NEQUAL; 
			:}
			|
			EQUAL:tok
			{:
				RESULT = BinaryOps.EQUAL; 
			:}
			;

munop::=	MINUS:tok
			{:
				RESULT = UnaryOps.UMINUS; 
			:} 
			%prec UMINUS
			;
lunop::=	LNEG:tok
			{:
				RESULT = UnaryOps.LNEG; 
			:}
			;

literal::= 	INTEGER:tok
			{: 
				Object[] ltrl = new Object[2];
				ltrl[0] = (Object)LiteralTypes.INTEGER;
				ltrl[1] = (Object)tok;
				RESULT = ltrl;
			:}
			|
			QUOTE:tok
			{:
				Object[] ltrl = new Object[2];
				ltrl[0] = (Object)LiteralTypes.STRING;
				ltrl[1] = (Object)tok;
				RESULT = ltrl;
			:}
			|
			TRUE:tok
			{:
				Object[] ltrl = new Object[2];
				ltrl[0] = (Object)LiteralTypes.TRUE;
				ltrl[1] = (Object)tok;
				RESULT = ltrl;
			:}
			|
			FALSE:tok
			{:
				Object[] ltrl = new Object[2];
				ltrl[0] = (Object)LiteralTypes.FALSE;
				ltrl[1] = (Object)tok;
				RESULT = ltrl;
			:}
			|
			NULL:tok
			{:
				Object[] ltrl = new Object[2];
				ltrl[0] = (Object)LiteralTypes.NULL;
				ltrl[1] = (Object)tok;
				RESULT = ltrl;
			:}
			;
			